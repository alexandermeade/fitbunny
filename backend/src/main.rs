use actix_web::{get, post, App, HttpServer, HttpResponse, Responder};
use actix_cors::Cors;
use openssl::ssl::{SslAcceptor, SslMethod, SslFiletype};
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey, Algorithm};
use serde::{Serialize, Deserialize};
use chrono::{Utc, Duration};
use actix_web::web;
use jsonwebtoken::TokenData;
use sqlx::postgres::PgPoolOptions;
use dotenvy::dotenv;
use std::env;
use actix_web::cookie::{Cookie, SameSite};
use actix_web::error::ErrorInternalServerError;
use sqlx::PgPool;
use actix_web::middleware::Logger;
mod jwt;
mod post;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,          // Subject (user ID or email)
    exp: usize,           // Expiration time (as a timestamp)
    iat: usize,           // Issued at
    iss: String,          // Issuer
}

#[derive(Deserialize)]
struct LoginData {
    email: String,
    password: String,
    username: String,
}

#[derive(Serialize)]
struct LoginResponse {
    success: bool,
    message: String,
}


#[get("/")]
async fn hello() -> impl Responder {
    HttpResponse::Ok().body("Hello, world!")
}

/*
#[post("/sus")]
async fn sus_handler(info: web::Json<LoginInfo>) -> impl Responder {
    let msg = format!("Got username: {}", info.username);
    HttpResponse::Ok().body(msg)
}
*/

#[actix_web::main]
async fn main() -> std::io::Result<()> {

    env_logger::init();
    dotenvy::dotenv().expect("Failed to read .env file");
    println!("check: {:?}", jwt::verify_jwt(&jwt::generate_JWT("some_email".to_string())));
    let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let ip = "127.0.0.1";
    let port = 8080;
    let pool = PgPoolOptions::new()
        .max_connections(10)
        .connect(&db_url)
        .await
        .map_err(|e| actix_web::error::InternalError::from_response(
            e,
            HttpResponse::InternalServerError().json(LoginResponse {
                success: false,
                message: "DB connection failed".to_string(),
            }),
        )).unwrap();



    let mut builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())
        .unwrap();
    
    /*
    builder.set_private_key_file("key.pam", SslFiletype::PEM)
        .unwrap();
    builder.set_certificate_chain_file("cert.pam").unwrap();
    */
    println!("active on: {ip}{port}");

    HttpServer::new(move || {
        App::new()
            .wrap(
            Cors::default()
                //.allowed_origin("https://your-frontend.com") // ✅ only allow your frontend
                .allowed_methods(vec!["GET", "POST", "PUT", "DELETE"])
                .allowed_headers(vec!["Content-Type", "Authorization"])
                .supports_credentials() // ✅ only if you're using cookies/session
                .allowed_origin("http://localhost:5173")

        )
            .wrap(Logger::default()) // <-- add this
            .app_data(web::Data::new(pool.clone()))  // Add pool here once
            .service(hello) //get
            .service(jwt::JWT_test)
            .service(post::signup)//POST singup
            .service(post::get_personal_info)
    })
    .bind((ip, port))?
    //.bind_openssl((ip, port), builder)?
    .run()
    .await
}

